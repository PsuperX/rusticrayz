// use rusticrayz::Application;
//
// fn main() {
//     tracing_subscriber::fmt::init();
//
//     let mut app = Application::new("Rusticrays");
//     app.run();
// }

use bevy::{
    prelude::*,
    render::{
        render_asset::RenderAssets,
        render_graph::{Node, RenderGraph},
        render_resource::{BindGroupLayout, CachedComputePipelineId, PipelineCache},
        renderer::RenderDevice,
        Render, RenderApp, RenderSet,
    },
};

fn main() {
    tracing_subscriber::fmt::init();

    App::new().add_plugins(DefaultPlugins).run();
}

const RAYTRACER_PASS: &str = "raytracer_pass";

struct RaytracerPlugin;

impl Plugin for RaytracerPlugin {
    fn build(&self, app: &mut App) {
        let Ok(render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };

        render_app.add_systems(
            Render,
            prepare_bind_group.in_set(RenderSet::PrepareBindGroups),
        );

        let mut graph = render_app.world.resource_mut::<RenderGraph>();
        let draw_3d_graph = graph
            .get_sub_graph_mut(bevy_core_pipeline::core_3d::graph::NAME)
            .unwrap();
        draw_3d_graph.add_node(RAYTRACER_PASS, RaytracerPassNode::default());
        draw_3d_graph.add_slot_edge("swapchain", "window_view", RAYTRACER_PASS, "color_buffer");
        draw_3d_graph.add_node_edge(
            RAYTRACER_PASS,
            bevy_core_pipeline::core_3d::graph::node::START_MAIN_PASS,
        );
    }
    fn finish(&self, app: &mut App) {
        let render_app = app.sub_app_mut(RenderApp);
        render_app.init_resource::<RtPipeline>();
    }
}

#[derive(Resource)]
struct RtPipeline {
    bind_group_layout: wgpu::BindGroupLayout,
    pipeline: CachedComputePipelineId,
}

impl FromWorld for RtPipeline {
    fn from_world(world: &mut World) -> Self {
        let bind_group_layout = world.resource::<RenderDevice>().create_bind_group_layout(
            None,
            &wgpu::BindGroupLayoutEntries::single(
                wgpu::ShaderStages::COMPUTE,
                texture_storage_2d(
                    wgpu::TextureFormat::Rgba8Unorm,
                    wgpu::StorageTextureAccess::ReadWrite,
                ),
            ),
        );
        let shader = world
            .resource::<AssetServer>()
            .load("shaders/raytracer.wgsl");
        let pipeline_cache = world.resource::<PipelineCache>();
        let pipeline = pipeline_cache.queue_compute_pipeline(wgpu::ComputePipelineDescriptor {
            label: None,
            layout: vec![texture_bind_group_layout.clone()],
            push_constant_ranges: Vec::new(),
            shader: shader.clone(),
            shader_defs: vec![],
            entry_point: Cow::from("init"),
        });

        Self {
            bind_group_layout,
            pipeline,
        }
    }
}

#[derive(Debug, Default)]
struct RaytracerPassNode;

impl Node for RaytracerPassNode {
    fn run(
        &self,
        graph: &mut bevy::render::render_graph::RenderGraphContext,
        render_context: &mut bevy::render::renderer::RenderContext,
        world: &bevy::prelude::World,
    ) -> Result<(), bevy::render::render_graph::NodeRunError> {
        let kernel_pipeline = world.resource::<RtPipeline>();
        let kernel_bind_group = world.resource::<RtBindGroup>();
        let pipeline_cache = world.resource::<PipelineCache>();
        let color_buffer = world.resource::<ColorBuffer>();

        let mut rt_compute_pass =
            render_context
                .command_encoder()
                .begin_compute_pass(&wgpu::ComputePassDescriptor {
                    label: Some("rt_compute_pass"),
                });

        if let Some(real_pipeline) = pipeline_cache.get_compute_pipeline(kernel_pipeline.pipeline) {
            println!("dispatch happening");
            rt_compute_pass.set_pipeline(&real_pipeline);
            rt_compute_pass.set_bind_group(0, &kernel_bind_group.0, &[]);
            rt_compute_pass.dispatch_workgroups(
                color_buffer.size.x as u32,
                color_buffer.size.y as u32,
                1,
            );
        }
        Ok(())
    }
}

#[derive(Resource)]
struct RtBindGroup(wgpu::BindGroup);

fn prepare_bind_group(
    mut commands: Commands,
    pipeline: Res<RtPipeline>,
    gpu_images: Res<RenderAssets<Image>>,
    render_device: Res<RenderDevice>,
) {
    let view = gpu_images.get(&game_of_life_image.0).unwrap();
    let bind_group = render_device.create_bind_group(
        None,
        &pipeline.texture_bind_group_layout,
        &BindGroupEntries::single(&view.texture_view),
    );
    commands.insert_resource(GameOfLifeImageBindGroup(bind_group));
}

#[derive(Resource)]
struct ColorBuffer(wgpu::Buffer);
